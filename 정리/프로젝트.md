# ⚽ 캠퍼스 내 스포츠 시설 예약 및 커뮤니티 플랫폼  ⚽
 <h4> 캠퍼스 내 스포츠 시설 예약 및 사용 방식을 불편함을 해소하고<br><br> 간편한 스포츠 시설 예약 및 커뮤니케이션 경험을 제공하기 위해 웹 앱으로 개발하였습니다.</h4>
 
<br>


## <b> 🗂️ 목차 </b>
-   ### <b> <a href="#0"> 🧑‍🤝‍🧑 팀원 소개 </a> </b>
-   ### <b> <a href="#0.5"> 😄 서비스 소개 </a> </b>
-   ### <b> <a href="#2">  🛠️ 메인 기술 스택  </a> </b>
-   ### <b> <a href="#4"> 👍 특장점 기술  </a> </b>
-   ### <b> <a href="#5"> 🚀 트러블 슈팅 </a> </b>

<h2 id="0">
	
## <b>🧑‍🤝‍🧑 팀원 소개</b>

</h2>
<div align="centered-table">
    <table>
        <tr>
            <td style="text-align:center;"><img src="https://github.com/GNU-SPORTS/.github/assets/97229292/e4b47807-c1a1-4f03-a604-e665e0b7d2b8.png" width="200" height="165"></td>
            <td style="text-align:center;"><img src="https://github.com/juni0914/caps2023_front/assets/100837725/44b9049b-4488-45d9-bacc-1b8482068c4f" width="200" height="165"></td>
            <td style="text-align:center;"><img src="https://github.com/GNU-SPORTS/.github/assets/100845256/ce9513e3-4bb4-4283-9d42-c961082edd2b" width="200" height="165"></td>
        </tr>
        <tr>
            <td style="text-align:center;"><strong>Front-End(Android)</strong></td>
            <td style="text-align:center;"><strong>Front-End(React)</strong></td>
            <td style="text-align:center;"><strong>Back-End(Spring)</strong></td>
        </tr>
        <tr>
            <td style="text-align:center;"><a href="https://github.com/younghyeok-k">younghyeok-k</a></td>
            <td style="text-align:center;"><a href="https://github.com/juni0914">juni0914</a></td>
            <td style="text-align:center;"><a href="https://github.com/Jorados">Jorados</a></td>
        </tr>
    </table>
</div>

<h2 id="0.5">
	
## <b>😄 서비스 소개</b>
</h2>

- #### 로그인 및 회원가입: 사용자는 개인 계정을 생성하고 관리하여 플랫폼의 모든 기능을 이용 가능 ####
- #### 스포츠 시설 예약 및 취소: 사용자는 편리한 인터페이스를 통해 스포츠 시설을 예약하고 필요한 경우 예약을 취소할 수 있음 ####
- #### 커뮤니티 활동: 사용자들은 플랫폼 내에서 글쓰기, 삭제, 수정, 댓글 쓰기, 삭제 등의 커뮤니티 활동을 통해 스포츠와 관련된 정보와 경험을 공유하고 소통 가능 ####
- #### 닉네임 변경 및 포인트 충전: 사용자는 닉네임을 변경하거나 포인트를 충전하여 플랫폼의 기능을 보다 편리하게 이용할 수 있음 ####
- #### 내가 쓴 글과 댓글 관리: 사용자는 작성한 글과 댓글을 한눈에 확인하고 관리할 수 있어 자신의 활동을 손쉽게 추적 가능 ####
  

<h2 id="2">
	
## 🛠️ 메인 기술 스택   

</h2>
<div align="center">
    <h3>Front-End-Web</h3>
    <div>
        <img src="https://img.shields.io/badge/react-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB"/>
        <img src="https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E"/>
        <img src="https://img.shields.io/badge/NPM-%23CB3837.svg?style=for-the-badge&logo=npm&logoColor=white"/>
        <img src="https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white"/>
        <img src="https://img.shields.io/badge/css3-%231572B6.svg?style=for-the-badge&logo=css3&logoColor=white"/>
    </div>
    <h3>Front-End-App</h3>
    <div>
        <img src="https://img.shields.io/badge/Kotlin-7F52FF.svg?&style=for-the-badge&logo=Kotlin&logoColor=white"/>
        <img src="https://img.shields.io/badge/Android-3DDC84.svg?&style=for-the-badge&logo=Android&logoColor=white"/>
    </div>
    <h3>Back-End</h3>
    <div>
        <img src="https://img.shields.io/static/v1?style=for-the-badge&message=Java&color=007396&logo=Java&logoColor=FFFFFF&label="/>
        <img src="https://img.shields.io/static/v1?style=for-the-badge&message=Spring+Boot&color=6DB33F&logo=Spring+Boot&logoColor=FFFFFF&label="/>
        <img src="https://img.shields.io/static/v1?style=for-the-badge&message=JPA&color=F05032&logo=JPA&logoColor=FFFFFF&label="/>
        <img src="https://img.shields.io/static/v1?style=for-the-badge&message=MySQL&color=4479A1&logo=MySQL&logoColor=FFFFFF&label="/>
    </div>
    <h3>Production & Deploy</h3>
    <div>
      <img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&logo=amazon-aws&logoColor=white"/>
    </div>
     <h3>Collaboration tool</h3>
    <div>
      <img src="https://img.shields.io/badge/git-%23F05033.svg?style=for-the-badge&logo=git&logoColor=white"/>
      <img src="https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&logo=github&logoColor=white"/>
    </div>
</div>          

## 🗂️ System Architecture

![KakaoTalk_20230808_164819868](https://github.com/GNU-SPORTS/.github/assets/100845256/434cc0e9-2248-48e7-b0d8-e150d23f657f)
   
## 💾 ERD Structure

![image](https://github.com/GNU-SPORTS/.github/assets/100845256/8c3af6a8-6db5-4735-bf0c-12fc52039ad3)

<h2 id="4">
	
## 👍 특장점 기술 
</h2>
<details>
<summary>
<h3> ✨ 현재위치기반의 날씨 정보(안드로이드)</h3>
</summary>
<div markdown="1">

   - 현재위치기반의 날씨 정보
   - 사용자의 현재 위치를 기반으로 날씨 정보를 제공하여 실내 및 야외 스포츠 활동을 계획하는 데 도움을 줌
   - 기상청에서 제공하는 단기 예보 API를 통해 현재 위치의 날씨 상황을 알 수 있음
   - 또한 매일 하루를 준비할 때 날씨에 따른 필요한 우산, 기온 별 옷차림, 야외 상황, 뉴스 정보를 알려 줌

</div>
</details>


<h2 id="5">

</h2>
<details>
<summary>
<h3> ✨ JWT 토큰을 이용한 인증,인가 서버 구축</h3>
</summary>
<div markdown="1">
	
   - JWT와 Spring Security를 이용한 서버 구축
   - JWT토큰 생성시 HMAC512 즉, SHA-512 해시 함수를 이용한 인증 토큰 생성.   
   - 대칭키 (Symmetric Key) 암호화 알고리즘 방식이다. 서버의 비밀 키를 사용하여 데이터를 암호화하고 복호화한다.    
   - 인증필터(UsernamePasswordAuthenticationFilter), 권한 허가 필터(BasicAuthenticationFilter) 상속 후 직접 메소드 오버라이딩         

```
@Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {

        log.info("successfulAuthentication 실행됨 : 인증이 완료되었다는 뜻임.");
        PrincipalDetails principalDetailis = (PrincipalDetails) authResult.getPrincipal();

        //hash 암호 방식
        String jwtToken = JWT.create()
                .withSubject(principalDetailis.getUsername())
                .withExpiresAt(new Date(System.currentTimeMillis()+JwtProperties.EXPIRATION_TIME))
                .withClaim("id", principalDetailis.getUser().getId())
                .withClaim("username", principalDetailis.getUser().getUsername())
                .sign(Algorithm.HMAC512(JwtProperties.SECRET));

        response.addHeader(JwtProperties.HEADER_STRING, JwtProperties.TOKEN_PREFIX+jwtToken);
        CustomResponseUtil.success(response, principalDetailis.getUser());
    }
```

### Autentication 인증
  - Authentication 요청(로그인 요청)이 발생하면 서버에서 attemptAuthentication() 함수가 실행된다. 그러면 해당 유저의 정보를 오브젝트로 파싱 후, UsernamePasswordAuthenticationToken() 객체를 생성한다.
  - 그러면 PrincipalService의 loadUserByUsername() 함수가 실행되어 DB를 확인 후 Authentication 객체를 만들어낸다. 그럼 해당 정보를 가져올수있다. PrincipalDetails 즉, DB에서 해당 유저를 찾은 것이다.   
  - 그 이후 successfulAuthentication() 함수가 실행되며 메소드 오버라이딩에 의해 재정의된 메소드에서 위에서 만든 PrincipalDetails 를 암호화 JWT토큰을 만드는 과정을 진행한다.
  - 이 때 JWT 인증 토큰 생성 방식은 HMAC512 즉,SHA-512 해시 함수를 이용한다. 이렇게 함으로써 조금 더 안전한 서버만의 유저 인증을 식별하는 JWT 인증 토큰이 만들어지게 되고 Response 헤더에 이 토큰을 담아서 보낸다.   

### Authorizaiton 인가
  - 내가 직접 설정한 Spring SecurityConfig에서 authorizeHttpRequests() 의 처리해 놓은 부분(인가가 필요한 요청)에 걸치게 되면 바로 authorization에서 허가 작업이 진행된다.    
  - 처음으로 인증 권한이 필요한 주소요청이 있을 때 Security 권한 허가 필터 객체인 BasicAuthenticationFilter의 doFilterInternal() 필터를 거치게 되는데 여기서 메소드 오버라이딩을 이용해 재정의한다.
  -  내가 지정한 Bearer 타입의 토큰 유무를 검사하고 다음으로 Bearer를 떼어내고 서버의 개인키를 이용해서 복호화를 진행한다. 그리고 토큰에 서명된 정보가 정상적인 정보인지 확인을 거친다.
  -  그리고 이 서명 정보가 정상적이라면, UsernamePasswordAuthenticationToken() 객체를 만들어 강제로 시큐리티 세션에 접근하여 authentication 객체를 저장해준다.
  -  이유는 Authorizaiton은 UserDetailsService를 호출하지 않기 때문에 @AuthenticationPrincipal 사용이 불가능하기 때문이다.

</div>
</details>


<h2 id="5">
	
## 🚀 트러블 슈팅
</h2>

### 🧑🏻‍💻 안드로이드
<details>
<summary>
<h3>🛠 트러블 슈팅 </h3>
</summary>
<div markdown="3">

- **Problem & Reason**
  - 기존의 sharedprefernce 만 사용하는 방식을 사용
  - 기존 방식은 토큰을 SharedPreferences에 저장하고 필요할 때마다 수동으로 토큰을 가져와 요청 헤더에 추가
  - 이로 인해 각각의 요청에서 토큰을 일일이 관리하고 추가해야 하는 번거로움이 있고, 코드 낭비가 심하다고 느낌

- **To Solve**
  - Interceptor를 함께 사용하는 방식
  - Interceptor를 사용하면 네트워크 라이브러리에서 토큰 관련 작업을 자동으로 처리
  - 각각의 네트워크 요청에서 토큰 추가 작업을 수동으로 하지 않아도 되며, 중복 코드를 줄이고 효율적으로 토큰 관리
```
private val okHttpClient = OkHttpClient.Builder()
        .connectTimeout(5, TimeUnit.MINUTES)
        .readTimeout(5, TimeUnit.MINUTES)
        .writeTimeout(5, TimeUnit.MINUTES)
        .addInterceptor(interceptor)
        .addInterceptor(TokenInterceptor()) // Bearer 토큰 추출 및 요청 헤더에 추가
        .addInterceptor(BearerTokenInterceptor())
        .build()

    val retrofit: Retrofit by lazy {
        sharedManager = SharedManager.getInstance() // SharedManager 초기화
        Retrofit.Builder()
            .client(okHttpClient)
            .baseUrl(BASE_URL)
            .addConverterFactory(ScalarsConverterFactory.create())
            .addConverterFactory(GsonConverterFactory.create())
            .build()
    }

    fun getInstance(): Retrofit {
        return retrofit
    }

    private class BearerTokenInterceptor : Interceptor {
        @Throws(IOException::class)
        override fun intercept(chain: Interceptor.Chain): Response {
            val originalRequest = chain.request()

            // Bearer 토큰 값 가져오기
            val bearerToken = sharedManager.getBearerToken()

            // Bearer 토큰이 존재하는 경우 요청 헤더에 추가
            if (!bearerToken.isNullOrEmpty()) {
                val modifiedRequest = originalRequest.newBuilder()
                    .header("Authorization", "Bearer $bearerToken")
                    .build()
                return chain.proceed(modifiedRequest)
            }
            Log.d("BearerToken", bearerToken)
            return chain.proceed(originalRequest)
        }
    }
}

```
</div>




<summary>
<h3>🛠  트러블 슈팅 2</h3>
</summary>
<div markdown="4">

- **Problem & Reason**
  - 모든 글 정보API를 호출할때 한번에 20개로 제한이 되어있어 페이지를 따로 만들어야하는 낭비가 생김
  - 또한 글 검색을 할때 현재 페이지 글만 검색되는 오류 발견
  - 페이지 오래된 순 최신순 정렬 시 현재 페이지 글만 가능

- **To Solve**
  - 모든 글 정보API를 사용하지 않고 특정 글 정보API를 이용하여 글을 하나씩 모든 글 번호를 호출하여 RecyclerView로 보여줌
  - 스크롤을 내릴 때마다 글 하나씩 호출하여 계속해서 글을 가져옴
  - 모든 글 정보를 가져와서 page 처리하지 않고 특정 글 가져오는 api를 이용하여 메모리 낭비를 줄임
  - 글 검색시 모든 페이지 글 검색 가능

PostViewmodel.kt
  ```
   private var page = 0;

    suspend fun loadMore() {
        if (isLoading.value) return
        if (isLast) return

        isLoading.value = true

        val response = suspendCoroutine<PostsResponse> {
            apiService.searchPosts("title", query.value, _sortType.value.value, 20, page)
                .enqueue(object : Callback<PostsResponse> {
                    override fun onResponse(
                        call: Call<PostsResponse>,
                        response: Response<PostsResponse>
                    ) {
                        it.resumeWith(Result.success(response.body() ?: PostsResponse().apply {
                            last = true
                        }))
                    }

                    override fun onFailure(call: Call<PostsResponse>, t: Throwable) {
                        t.printStackTrace()

                        it.resumeWith(Result.success(PostsResponse().apply {
                            last = true
                        }))
                    }
                })
        }

        isLoading.value = false

        val result = if (page == 0) {
            response.content
        } else {
            posts.value + response.content
        }

        page += 1
        isLast = response.last
        posts.emit(result)
    }
}

enum class PostSortType(val value: String) {
    LATEST("latest"),
    OLDEST("oldest")
}

  ```
Postfragment.kt
```
private val launchEditor =
        registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                lifecycleScope.launch {
                    viewModel.refresh()
                }
            }
        }

    private val launchViewer =
        registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                val old: Post? = result.data?.getParcelableExtra("old")
                val new: Post? = result.data?.getParcelableExtra("new")

                if (old == null) return@registerForActivityResult

                val posts = ArrayList(viewModel.posts.value)
                val index = posts.indexOfFirst { it.id == old.id }
                if (index >= 0) {
                    if (new != null) {
                        posts[index] = new;
                    } else {
                        posts.removeAt(index)
                    }

                    viewModel.posts.tryEmit(posts)
                }
            }
        }
```

</div>
</details>

### 🧑🏻‍💻 리액트
<details>
<summary>
<h3>🛠 트러블 슈팅 </h3>
</summary>
<div markdown="4">
  
- **Problem & Reason**  
	- 서버에서 현재 시간과 비교하여 현재 시간보다 지난 시간은 예약이 되지 않게 시간 버튼을 비활성화해야 한다.
	- 기존 방식을 채택하니 현재 시각이 16시 05분이면, 16시 이전 버튼이 비활성화가 되어야 하는데, 오늘 이후의 날도 16시 이전 버튼이 비활성화되는 부분 발생했다.
	- 예약 시스템에서 예약 가능한 시간대를 동적으로 생성하고 상태를 관리하는 중요한 기능

- **To Solve**   
	- 이용 가능 시간 추출: reservationInfo.center 객체에서 openTime과 closeTime을 추출하여 이용 가능한 시간대 범위를 정의
	- 예약된 시간 추출: reservationInfo.reservedTimes 배열에서 이미 예약된 시간대들을 추출
	- 날짜 및 시간 정보 추출: 현재 시간과 선택된 날짜에 대한 연도, 월, 일, 시간, 분 정보를 추출
	- 버튼 상태 설정: 각 버튼의 ID를 시간 형식으로 생성하고, 해당 시간이 이미 예약된 시간 목록에 있는지를 확인하여 isReserved 상태를 설정.  또한, 오늘 날짜의 버튼 중 현재 시간 이전 버튼은 비활성화

```
function generateReservationButtons() {
    // 이용 가능 시간 추출
    const { openTime, closeTime } = reservationInfo.center;
    const startTime = parseInt(openTime.split(":")[0]).toString().padStart(2, "0");
    const endTime = parseInt(closeTime.split(":")[0]);
  
    const reservedTimes = reservationInfo.reservedTimes || [];
    const buttons = [];
  
    const now = new Date();
    const currentYear = now.getFullYear();
    const currentMonth = (now.getMonth() + 1).toString().padStart(2, "0");
    const currentDate = now.getDate().toString().padStart(2, "0");
    const currentHour = now.getHours().toString().padStart(2, "0");
    const currentMinutes = now.getMinutes().toString().padStart(2, "0");
  
    const selectedYear = selectedDate.getFullYear();
    const selectedMonth = (selectedDate.getMonth() + 1).toString().padStart(2, "0");
    const selectedDay = selectedDate.getDate().toString().padStart(2, "0");
  
    for (let i = startTime; i < endTime; i++) {
      for (let j = 0; j < 60; j += 30) {
        const hour = i.toString().padStart(2, "0");
        const minute = j.toString().padStart(2, "0");
        const buttonId = `${hour}:${minute}`;
        const isReserved = reservedTimes.includes(buttonId);
  
        // 오늘 날짜의 버튼 중 현재 시간 이전 버튼 비활성화
        let isDisabled = false;
  
        if (selectedYear === currentYear && selectedMonth === currentMonth && selectedDay === currentDate) {
          isDisabled = parseInt(currentHour) > i || (parseInt(currentHour) === i && currentMinutes >= j);
        }
        buttons.push(
          <Button
            key={buttonId}
            variant={isSelected(buttonId) ? "success" : isDisabled || isReserved ? "light" : "outline-success"}
            className={`w-25 ${isSelected(buttonId) ? "selected" : ""}`}
            onClick={() => handleReservationTimeSelect(buttonId)}
            disabled={isDisabled || isReserved}
          >
            {buttonId}
          </Button>
        );
      }
    }
    return buttons;
  }

```
</div>




<summary>
<h3>🛠  트러블 슈팅 2</h3>
</summary>
<div markdown="4">
  
- **Problem & Reason**   
	- 특정 예약을 삭제한 후 예약 데이터와 관련된 상태를 업데이트해야 한다.
	- 예약은 바로 삭제가 되나, 삭제한 예약 데이터가 클라이언트 상에서 계속 존재하여 예약이 불가능한 상황이 발생했다.
	- 예약 시스템에서 특정 예약을 삭제한 후 관련된 상태를 업데이트하여 예약 데이터를 관리하는 중요한 기능을 수행. 센터 ID와 예약 ID에 해당하는 예약 데이터를 삭제하고, 관련된 상태를 업데이트하여 애플리케이션의 일관성을 유지해야 하는 기능

- **To Solve**   
	- filter 메서드를 사용하여 삭제되지 않은 예약을 제외한 업데이트된 예약 데이터를 생성. 이때, centerId와 reservationId가 같지 않은 경우에만 해당 예약 데이터를 유지
	- setReserveData(예약데이터), setReserveId(예약ID), setReservecenterId(센터ID) state 를 사용하여 상태를 업데이트하고, 삭제되지 않은 업데이트된 예약 데이터를 적용
	- setDeletedReservations(삭제된 예약데이터) state 를 사용하여 삭제된 예약 내역을 업데이트

```
const updateReservationData = (centerId, reservationId) => {
  // 기존 예약 내역에서 삭제된 예약을 제외하고 업데이트된 예약 내역을 생성합니다.
  const updatedReserveData = reserveData.filter((name, index) => reservecenterId[index] !== centerId || reserveId[index] !== reservationId);
  const updatedReserveIds = reserveId.filter((id, index) => reservecenterId[index] !== centerId || id !== reservationId);
  const updatedCenterIds = reservecenterId.filter((id, index) => id !== centerId || reserveId[index] !== reservationId);
  
  // 예약 내역 상태를 업데이트합니다.
  setReserveData(updatedReserveData);
  setReserveId(updatedReserveIds);
  setReservecenterId(updatedCenterIds);

  // 삭제된 예약 내역을 업데이트합니다.
  const updatedDeletedReservations = reserveData.filter((name, index) => reservecenterId[index] !== centerId || reserveId[index] !== reservationId);
  setDeletedReservations(updatedDeletedReservations);
};
```
</div>


<summary>
<h3>🛠  트러블 슈팅 3</h3>
</summary>
<div markdown="4">
  
- **Problem & Reason**   
	- login을 처리하는 api로 로그인 데이터를 post 한 후, response를 받고 로컬스토리지에 서버로부터 받은 jwt 토큰을 set 하여 토큰을 로컬스토리지에 저장하는 로그인 방식
	- 하지만 로그인 동작을 수행하면 서버에는 로그인 요청이 시도가 되지만 실패하는 상황 발생하여 프론트단에서 문제가 있다고 인지
	- 로그인을 시도할 때, 한 번에 완료되는 경우도 있고, 몇 번을 시도해도 완료되지 않고, 로그인이 실패하는 치명적인 오류가 발생
	- 원인은 js 버튼 동작에 있었다. 로그인 버튼의 코드에는 새로고침을 하게 되는 동작이 포함되어 있는데, 로그인을 처리하는 과정을 끝마치고 새로고침을 하는 동작이 완료가 되어야 한다.
	- 코드 실행시간 및 순서에 따라 버튼 함수의 새로고침 동작이 먼저 수행되어서 올바르게 response를 넘겨받고, 로컬스토리지에 JWT를 등록하는 과정이 정상적으로 진행되지 못한 것이다.

- **To Solve**  
	- <button> 요소의 타입: 로그인 버튼의 타입을 <button type="submit">으로 설정하면, 클릭 시 폼의 기본 동작인 페이지 새로고침을 수행한다.
	- 이를 방지하기 위해서는 <button>의 타입을 "button"으로 설정해야 한다. 버튼의 새로고침 동작이 있을 경우 페이지가 새로고침되어서 현재 작업 중인 상태를 초기화하고 모든 네트워크 요청이 중단될 수 있다.
	- 따라서, 버튼 클릭과 같은 사용자 동작에 의해 새로고침이 발생하지 않도록 preventDefault() 함수를 사용하면 된다.

```
<button onClick={login} type="button">Login</button>  //로그인 버튼 JSX

const handleKeyPress = (event) => {      // 로그인 버튼을 눌렀을 때 작동하는 함수
    if (event.key === 'Enter') {
      event.preventDefault(); 
      login();
    }
  };
```
</div>

</details>


### 🧑🏻‍💻 백엔드
<details>
<summary>
<h3>🛠 트러블 슈팅 </h3>
</summary>
<div markdown="4">

- **Problem & Reason**   
  - 예약 시간을 담당하는 ReservationTime 객체를 어떻게 만들어서 예약시간을 처리해야 하는지에 대해서 많은 고민을 했습니다.   
  - 왜냐하면, 예약할 때 받아오는 예약 시간대를 구분하기 어려웠기 때문입니다.

- **To Solve**   
  - List<> 형태로 Center는 CenterReservation을 가집니다.
  - 근데 여기서 Center를 Reservation 할 때 예약 시간을 구분하기 위해서,      
  - 저는 Enum 타입의 CenterReservation을 생성해서 각각의 시간을 구분할 수 있게 하였습니다.
```
@Getter
@AllArgsConstructor
public enum ReservingTime {
    RT1("00:00"),
    RT2("00:30"),
    RT3("01:00"),
    RT4("01:30"),
    RT5("02:00"),
    RT6("02:30"),
    RT7("03:00"),
    RT8("03:30"),
    RT9("04:00"),
    RT10("04:30"),
    RT11("05:00"),
    RT12("05:30"),
    RT13("06:00"),
    RT14("06:30"),
    RT15("07:00"),
    RT16("07:30"),
    RT17("08:00"),
    RT18("08:30"),
    RT19("09:00"),
    RT20("09:30"),
    RT21("10:00"),
    RT22("10:30"),
    RT23("11:00"),
    RT24("11:30"),
    RT25("12:00"),
    RT26("12:30"),
    RT27("13:00"),
    RT28("13:30"),
    RT29("14:00"),
    RT30("14:30"),
    RT31("15:00"),
    RT32("15:30"),
    RT33("16:00"),
    RT34("16:30"),
    RT35("17:00"),
    RT36("17:30"),
    RT37("18:00"),
    RT38("18:30"),
    RT39("19:00"),
    RT40("19:30"),
    RT41("20:00"),
    RT42("20:30"),
    RT43("21:00"),
    RT44("21:30"),
    RT45("22:00"),
    RT46("22:30"),
    RT47("23:00"),
    RT48("23:30"),
    RT49("24:00");

    private final String time;

    public static ReservingTime findTime(String findTime) {
        return Arrays.stream(ReservingTime.values())
                .filter(reservingTime -> reservingTime.getTime().equals(findTime))
                .collect(Collectors.toList())
                .get(0);
    }
}
```
</details>
